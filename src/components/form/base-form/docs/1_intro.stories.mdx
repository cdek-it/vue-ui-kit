import { Meta, Story } from '@storybook/addon-docs';

<Meta title="Form/Intro" />

# Форма

Базовая идея формы состоит в том, чтобы сделать описание формы только засчет параметров
этой самой формы. Она должна работать полностью автономно, выдавая на выходе объект, который
можно сразу отправлять на бэк.

### Базовая структура

Для работоспособности формы нужно использовать 2 компонента: `CdekForm` и `CdekFormControl`.
Первый работает, как обертка. Второй предоставляет элемент формы. Связь между ними устанавливается
сама, вложенность не важна.

Для базовой формы, которая будет собирать имя и фамилию, минимально нужен такой код:

```html dark
<CdekForm @submit="submit">
  <CdekFormControl name="firstName" />
  <CdekFormControl name="surname" />

  <button>Продолжить<button>
</CdekForm>
```

Где `name` для `CdekFormControl` - это будущее название свойства в объекте, а `submit` на `CdekForm`
позволяет подписаться на получение всего объекта при отправке формы.

По дефолту `CdekFormControl` будет отображать `CdekInput`, позже добавится поддержка дополнительных
компонентов.

Когда произойдет событие `submit` в форме из примера, в callback прийдет такой объект:

```js dark
{
  firstName: "значение",
  surname: "значение"
}
```

Что позволит вам сразу отправить этот объект на бэк, в случае если передавать корректный `name`,
который будет соответствовать полю в запросе.

> Введите данные в оба поля и нажмите "Продолжить"

<Story id="form-cdekform--primary" />

---

### Начальные значения

Для передачи начального значения, нужно в `CdekFormControl` передать параметр `initialValue`.

```html dark
<CdekFormControl name="firstName" initialValue="Имя" />
```

> Нажмите "Продолжить"

<Story id="form-cdekform--with-initial-values" />

---

### Зачем нужен новый механизм формы?

Сейчас механизм работы с формой выглядит так:

```html dark
<form class="form" @submit.prevent="onSubmit">
  <base-input <!-- Сами заводим переменную -->
    v-model="calcEmailForSendScan"
    <!-- Сами обрабатываем состояние ошибки -->
    :has-error="$v.calcEmailForSendScan.$error" >
    <template v-if="$v.calcEmailForSendScan.$error" #message>
      <!-- Сами выбираем сообщение об ошибке -->
      <span v-if="!$v.calcEmailForSendScan.required">
        {{ $t('requiredField') }}
      </span>
      <span
        v-if="$v.calcEmailForSendScan.required && !$v.calcEmailForSendScan.email"
      >
        {{ $t('enterEmail') }}
      </span>
    </template>
  </base-input>
</form>
```

```js dark
import { required, email } from 'vuelidate/lib/validators';

export default {
  data: () => ({
    calcEmailForSendScan: '',
  }),
  // Приходится искать блок `validations`, чтобы понять, как поле валидируется
  validations() {
    return {
      calcEmailForSendScan: {
        required,
        email,
      },
    };
  },
  onSubmit() {
    // Мануально триггерим проверку
    this.$v.$touch();
    // Проверяем
    if (!this.$v.$invalid) {
      this.$emit('submit', { calcEmailForSendScan: this.calcEmailForSendScan });
    }
  },
};
```

Обработка форм - это базовая операция, с которой мы достаточно часто сталкиваемся. В данном
примере хорошо чувствуются повторяющиеся действия:

1. Регистрация переменных
2. Обработка ошибки (поддержка состояния, вывод сообщений)
3. Поддержка дополнительного блока validations
4. На сабмите нужно "тронуть" форму и проверить ошибку

Также у этой технологии есть ограничения, такие как поддержка нескольких форм в одном компоненте.

Если перевести этот пример на новые компоненты, он станет выглядеть так:

```js dark
// здесь должны быть валидации, показываю просто поддержку сообщения
const required = () => $t('requiredField');
const email = () => $t('enterEmail');

// эта функция вызовется, только если все валидации прошли успешно
const onSubmit = (values) => {
  // values = { calcEmailForSendScan: '<значение>' }
  // не нужно делать `touch` или какие-то проверки, форма делает это автоматически
  emit('submit', values);
};
```

```html dark
<CdekForm @submit="onSubmit">
  <!-- Явно видно на каком поле какая валидация -->
  <!-- Сообщение об ошибке показывается само, не нужно никакой обработки в базовом варианте -->
  <CdekFormControl name="calcEmailForSendScan" :rules="{ required, email }" />
</CdekForm>
```
